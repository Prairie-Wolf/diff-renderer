{"name":"DiffRenderer","tagline":"Smart innerHTML for your views.","body":"## Smart innerHTML for your views.\r\n\r\nDiffRenderer is a rendering component for your views, think of smart .innerHTML which renders only the changes.\r\n\r\n- high performance rendering\r\n- dramatically simplifies your view logic in non-trivial tasks\r\n- plays nicely with any library and web components\r\n\r\nFeel free to use any other project for events handling, templates, animations etc.\r\n\r\n```javascript\r\n\r\nvar DiffRenderer = require('diff-renderer')\r\n\r\nvar el = document.getElementById('my-view')\r\n\r\n// Create renderer instance associated with some parent DOM element.\r\nvar renderer = new DiffRenderer(el)\r\n\r\n// Put html you want to render.\r\nrenderer.update('<div>My content</div>')\r\n\r\n// Start rendering loop once.\r\nDiffRenderer.start()\r\n```\r\n\r\n## DOM is slow.\r\n\r\nIf your view state has changed, you would normally manually go through changes and apply them to the dom by manipulating dom nodes or overwriting the view completely with .innerHTML.\r\n\r\n1. Manipulating dom nodes in non trivial applications makes you view logic complicated.\r\n2. Using .innerHTML causes performance and memory issues.\r\n\r\n## Playground\r\n\r\nVisit [playground](//kof.github.com/diff-renderer/demo/playground.html) to see it in action.\r\n\r\n## Use cases\r\n\r\n1. Replacement for jQuery's dom manipulation methods and any direct dom manipulation.\r\n1. Easy RESTful http API implementation:\r\n   Client sends an object to the server, server validates it, client gets cleaned object back. With DiffRenderer we can apply the new one to the DOM without any checks.\r\n1. Full bidirectional binding. For this you need to add the part for handling events and changing the state/data objects manually.\r\n1. Real time data manipulation / rendering.\r\n\r\n## How\r\n\r\n1. It accepts a snapshot of your state in html or json format. You can use any template engine or none.\r\n1. It calculates the difference to the cached state of the dom.\r\n1. Intelligently renders the difference by only modifying/adding/removing nodes it has to.\r\n1. It always reuses DOM elements.\r\n\r\n## Gotchas\r\n\r\n1. Don't attach listeners to the elements within renderer container. Do event delegation.\r\n1. Don't change elements directly, use DiffRenderer. If you (or some lib) changed an element directly - refresh DiffRenderer.\r\n\r\n## Bench\r\n\r\n- html parser - 200kb of html parsed in 15ms to json on my mb air.\r\n```\r\n    npm i\r\n    make bench\r\n```\r\n- jsperf of html parser vs. dom parsers http://jsperf.com/domparser-vs-jsparser\r\n- manual html parser memory test: open ./test/memory.html, observe your engines memory, click some times on buttons and see what happens\r\n\r\n## Api\r\n\r\n- Use [requestAnimationFrame shim](https://github.com/kof/animation-frame) for older browsers.\r\n\r\n### Get the api\r\n\r\n1. Commonjs `var DiffRenderer = require('diff-renderer')`\r\n2. From global\r\n    - add script with browserified version from ./dist/diff-renderer.js\r\n    - var DiffRenderer = window.DiffRenderer\r\n\r\n### DiffRenderer(element)\r\n\r\nCreate a renderer instance. Pass DOM element which you don't want to modify by DiffRenderer. Think of main view element f.e. like Backbone.View.prototype.el.\r\n\r\n```javascript\r\nvar el = document.getElementById('my-view')\r\nvar renderer = new DiffRenderer(el)\r\n```\r\n\r\n### DiffRenderer#update(html)\r\n\r\nUpdate renderer state with the new html.\r\n\r\n```javascript\r\nrenderer.update('<div>My new html</div>')\r\n```\r\n\r\n### DiffRenderer#refresh()\r\n\r\nSerialize dom elements within renderer main element. You might need this if you modified the dom directly.\r\n\r\n```javascript\r\nvar el = document.getElementById('my-view')\r\nvar renderer = new DiffRenderer(el)\r\nrenderer.update('<div>My new html</div>')\r\n\r\n// Now me or some other library modifies the content (NOT RECOMMENDED)\r\nel.innerHTML = '<span>Test</span>'\r\n\r\n// Now you want renderer let know that content has changed.\r\nrenderer.refresh()\r\n```\r\n\r\n### DiffRenderer.start()\r\n\r\nStart the renderer loop. Now on each animation frame renderer will render all queued changes.\r\n\r\n```javascript\r\nDiffRenderer.start()\r\n\r\nvar el = document.getElementById('my-view')\r\nvar renderer = new Renderer(el)\r\n\r\nrenderer.update('My fresh content will be rendered in the next animation frame.')\r\n```\r\n\r\n### DiffRenderer.stop()\r\n\r\nStop render loop.\r\n\r\n### DiffRenderer.render()\r\n\r\nRender all queued changes from all renderer instances to the DOM. In the most cases you want to use `Renderer.start` instead.\r\n\r\n```javascript\r\nvar el1 = document.getElementById('my-view-1')\r\nvar renderer1 = new Renderer(el1)\r\nvar el2 = document.getElementById('my-view-2')\r\nvar renderer2 = new Renderer(el2)\r\n\r\n// Now all virtual changes will be applied to the DOM.\r\nDiffRenderer.render()\r\n```\r\n\r\n## Test\r\n- `make build`\r\n- Open the test suite ./test/index.html\r\n","google":"UA-262517-4","note":"Don't delete this file! It's used internally to help with page regeneration."}